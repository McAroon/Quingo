@implements IDisposable
@inject ISnackbar Snackbar

<MudText Typo="Typo.h5" GutterBottom>Players (@DisplayPlayerCount)</MudText>
@if (ShowPlayers && DisplayPlayers.Any())
{
    <div class="pb-2">
        <MudButton OnClick="() => { _expandPlayers = !_expandPlayers; }"
                   EndIcon="@(_expandPlayers ? Icons.Material.Filled.ExpandLess : Icons.Material.Filled.ExpandMore)">
            @(_expandPlayers ? "Hide Players" : "Expand Players")
        </MudButton>
    </div>
}

@if (ShowPlayers && _expandPlayers)
{
    <MudStack Row Wrap="Wrap.Wrap">
        @foreach (var player in DisplayPlayers)
        {
            <div class="mw-100">
                <MudText Typo="Typo.h6" GutterBottom>@RenderPlayerName(player, Size.Medium)</MudText>
                <table class="dl-table">
                    @if (Game.IsStateActive)
                    {
                        <tr>
                            <th>Status</th>
                            <td class="@PlayerStatusTextColorClass(player)">
                                @PlayerStatusText(player)
                            </td>
                        </tr>
                    }
                    @if (ShowLives)
                    {
                        <tr>
                            <th>Lives</th>
                            <td>@player.LivesNumber</td>
                        </tr>
                    }
                    <tr>
                        <th>Score</th>
                        <td>
                            <PlayerScoreInfo Score="player.Score"/>
                        </td>
                    </tr>
                </table>
                @RenderPlayer(player)
            </div>
        }
    </MudStack>
}
else
{
    <MudGrid>
        <MudItem xs="12" lg="8">
            @{
                var orderedPlayers = (!Game.IsTournament && ShowPlayers)
                ? Game.Players
                .OrderByDescending(p => p.Score.ScoreTotal)
                .ThenByDescending(p => p.Score.ScoreCells)
                .ThenBy(p => p.Score.ScoreErrorPenalties)
                .ThenBy(p => p.DrawState?.DrawnNodes?.Count ?? 0)
                .ToList()
                : Game.Players.ToList();
            }
            <MudTable Items="orderedPlayers">
                <HeaderContent>
                    @if (!Game.IsTournament && ShowPlayers)
                    {
                        <MudTh>Place</MudTh>
                    }
                    <MudTh>Name</MudTh>
                    @if (Game.IsStateActive)
                    {
                        <MudTh>Status</MudTh>
                    }
                    @if (ShowLives)
                    {
                        <MudTh>Lives</MudTh>
                    }
                    @if (ShowPlayers)
                    {
                        <MudTh>Score</MudTh>
                        <MudTh>Actions</MudTh>
                    }
                </HeaderContent>
                <RowTemplate>
                    @if (!Game.IsTournament && ShowPlayers)
                    {
                        var idx = orderedPlayers.IndexOf(context);
                        var place = ComputePlace(orderedPlayers, idx);
                        var medal = MedalForPlace(place);

                        <MudTd DataLabel="Place">
                            @((place == 0) ? "-" : $"{medal} {place}")
                        </MudTd>
                    }
                    <MudTd DataLabel="Name">
                        @RenderPlayerName(context, Size.Small)
                    </MudTd>
                    @if (Game.IsStateActive)
                    {
                        <MudTd DataLabel="Status">
                            <span class="@PlayerStatusTextColorClass(context)">@PlayerStatusText(context)</span>
                        </MudTd>
                    }
                    @if (ShowLives)
                    {
                        <MudTd DataLabel="Lives">@context.LivesNumber</MudTd>
                    }
                    @if (ShowPlayers)
                    {
                        <MudTd DataLabel="Score">
                            @{
                                string? note = null;
                                if (!Game.IsTournament && ShowPlayers)
                                {
                                    note = QualReasonPlayers(context, orderedPlayers, onlyPlayed: true);
                                }
                            }
                            <PlayerScoreInfo Score="context.Score" RankReason="@note" />
                        </MudTd>
                        <MudTd DataLabel="Actions">
                            @if (Player != context)
                            {
                                <MudButton Size="Size.Small" Color="Color.Primary" OnClick="() => ViewPlayer(context)">
                                    View
                                </MudButton>
                            }
                        </MudTd>
                    }
                </RowTemplate>
            </MudTable>
        </MudItem>
    </MudGrid>
}

<MudDialog @bind-Visible="_dialogVisible" Options="_dialogOptions">
    <TitleContent>
        <MudText Typo="Typo.h6">
            View Player: @_selectedPlayer?.PlayerName
        </MudText>
    </TitleContent>
    <DialogContent>
        @RenderPlayer(_selectedPlayer)
    </DialogContent>
</MudDialog>

@code {

    private RenderFragment RenderPlayer(PlayerInstance? player) => player == null
        ? null
        : @<CascadingValue Value="player">
              @if (Game.Preset.SeparateDrawPerPlayer)
              {
                  <QuestionList DrawState="player.DrawState"
                                ShowDetails="ShowDetails"
                                ItemsToDisplay="Game.Preset.CardSize"
                                TitleTypo="Typo.h6"
                                ScrollOnDraw="false" Row/>
              }
              <PlayerCard TitleTypo="Typo.h6" ReadOnly ShowDetails="ShowDetails"/>
          </CascadingValue>;

    private RenderFragment RenderPlayerName(PlayerInstance? player, Size iconSize) => player == null
        ? null
        : @<span class="d-flex align-center">
              @if (!player.IsPlayerConnected)
              {
                  <MudTooltip Text="Disconnected">
                      <MudIcon Icon="@Icons.Material.Filled.WarningAmber" Size="iconSize" Color="Color.Warning"
                               Class="d-flex mr-1"/>
                  </MudTooltip>
              }
              @player.PlayerName
          </span>;

    [CascadingParameter] public GameInstance Game { get; set; } = default!;

    [Parameter] public PlayerInstance? Player { get; set; }

    [Parameter] public bool ShowDetails { get; set; }

    private bool ShowLives => Game.Preset.LivesNumber > 0 && Game.Preset.EnableCall;

    private bool ShowPlayers => Player == null || ShowDetails;

    private IEnumerable<PlayerInstance> DisplayPlayers => Game.Players.Where(x => Player != x);

    private DialogOptions _dialogOptions = new()
    {
        MaxWidth = MaxWidth.Large,
        FullWidth = false,
        CloseButton = true
    };

    private PlayerInstance? _selectedPlayer;

    private bool _dialogVisible;

    private bool _expandPlayers;

    private string DisplayPlayerCount => Game.Preset.MaxPlayers > 0
        ? $"{Game.Players.Count} / {Game.Preset.MaxPlayers}"
        : Game.Players.Count.ToString();

    private string PlayerStatusText(PlayerInstance player) => player.Status switch
    {
        PlayerStatus.Ready or PlayerStatus.NotReady
            when Game.State is GameStateEnum.Active or GameStateEnum.Paused or GameStateEnum.FinalCountdown => "Playing",
        PlayerStatus.NotReady => "Not Ready",
        PlayerStatus.Ready when Game.State is GameStateEnum.Init => "Ready",
        PlayerStatus.Done => "Done",
        _ => "-"
    };

    private string PlayerStatusTextColorClass(PlayerInstance player) => player.Status switch
    {
        PlayerStatus.Ready or PlayerStatus.NotReady
            when Game.State is GameStateEnum.Active or GameStateEnum.Paused or GameStateEnum.FinalCountdown => "mud-warning-text",
        PlayerStatus.NotReady => "mud-error-text",
        PlayerStatus.Ready when Game.State is GameStateEnum.Init => "mud-success-text",
        PlayerStatus.Done => "mud-success-text",
        _ => string.Empty
    };

    private void ViewPlayer(PlayerInstance player)
    {
        _selectedPlayer = player;
        _dialogVisible = true;
    }

    protected override void OnInitialized()
    {
        Game.PlayerJoined += OnPlayerJoined;
        Game.UserTracker.ConnectionsChanged += OnConnectionsChanged;
        foreach (var player in Game.Players)
        {
            player.StateChanged += OnStateChanged;
            player.LifeLost += OnLifeLost;
        }
    }

    private void OnPlayerJoined(PlayerInstance player)
    {
        Snackbar.Add($"{player.PlayerName} has joined!", Severity.Info);
        player.StateChanged += OnStateChanged;
        player.LifeLost += OnLifeLost;
    }

    private void OnStateChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    private void OnConnectionsChanged(string userId, bool connected)
    {
        InvokeAsync(StateHasChanged);
    }

    private void OnLifeLost(PlayerInstance player)
    {
        if (player != Player)
        {
            Snackbar.Add($"{player.PlayerName} has lost a life ({player.LivesNumber})", Severity.Info);
        }
        else
        {
            var text = player.LivesNumber > 1
                ? $"{player.LivesNumber} lives left."
                : player.LivesNumber == 1
                    ? $"1 life left."
                    : "You have no more lives. Game over.";
            Snackbar.Add($"Incorrect! {text}", Severity.Error);
        }
    }

    public void Dispose()
    {
        Game.PlayerJoined -= OnPlayerJoined;
        Game.UserTracker.ConnectionsChanged -= OnConnectionsChanged;
        foreach (var player in Game.Players)
        {
            player.StateChanged -= OnStateChanged;
            player.LifeLost -= OnLifeLost;
        }
    }

    private static int ComparePlayersByScore(PlayerInstance a, PlayerInstance b)
    {
        int c;
        if ((c = b.Score.ScoreTotal.CompareTo(a.Score.ScoreTotal)) != 0) return c;
        if ((c = b.Score.ScoreCells.CompareTo(a.Score.ScoreCells)) != 0) return c;
        if ((c = a.Score.ScoreErrorPenalties.CompareTo(b.Score.ScoreErrorPenalties)) != 0) return c;

        var aDraw = a.DrawState?.DrawnNodes?.Count ?? 0;
        var bDraw = b.DrawState?.DrawnNodes?.Count ?? 0;
        if ((c = aDraw.CompareTo(bDraw)) != 0) return c;

        return 0;
    }

    private static bool SameRank(PlayerInstance a, PlayerInstance b)
        => ComparePlayersByScore(a, b) == 0;

    private static int ComputePlace(List<PlayerInstance> ordered, int idx)
    {
        if (ordered == null || idx < 0 || idx >= ordered.Count) return 0;
        int place = 1;
        for (int i = 1; i <= idx; i++)
            if (!SameRank(ordered[i], ordered[i - 1]))
                place = i + 1;
        return place;
    }

    private static string MedalForPlace(int place) => place switch
    {
        1 => "🥇",
        2 => "🥈",
        3 => "🥉",
        _ => ""
    };

    private static bool IsPlayed(PlayerInstance p)
        => p.Status == PlayerStatus.Done
           || (p.Score?.ScoreTotal ?? 0) > 0
           || ((p.DrawState?.DrawnNodes?.Count) ?? 0) > 0;

    private readonly record struct RankKey(int Total, int Cells, int Pen, int Draw);

    private static RankKey KeyOf(PlayerInstance p)
    {
        var total = p.Score?.ScoreTotal ?? 0;
        var cells = p.Score?.ScoreCells ?? 0;
        var pen = p.Score?.ScoreErrorPenalties ?? int.MaxValue;
        var draw = p.DrawState?.DrawnNodes?.Count ?? int.MaxValue;
        return new(total, cells, pen, draw);
    }

    private static int CompareKeys(RankKey a, RankKey b)
    {
        int c;
        if ((c = b.Total.CompareTo(a.Total)) != 0) return c;
        if ((c = b.Cells.CompareTo(a.Cells)) != 0) return c;
        if ((c = a.Pen.CompareTo(b.Pen)) != 0) return c;
        if ((c = a.Draw.CompareTo(b.Draw)) != 0) return c;
        return 0;
    }

    private static bool FullEqual(PlayerInstance a, PlayerInstance b)
        => CompareKeys(KeyOf(a), KeyOf(b)) == 0;

    private static int TieSizeFor(PlayerInstance player, List<PlayerInstance> ranked, bool onlyPlayed)
    {
        var pool = onlyPlayed ? ranked.Where(IsPlayed).ToList() : ranked;
        return pool.Count(p => FullEqual(p, player));
    }

    private static string DiffReason(PlayerInstance me, PlayerInstance other)
    {
        var a = KeyOf(me); 
        var b = KeyOf(other);
        if (a.Total != b.Total) return a.Total > b.Total ? "Выше по очкам (Total)" : "Ниже по очкам (Total)";
        if (a.Cells != b.Cells) return a.Cells > b.Cells ? "Выше по CellScore" : "Ниже по CellScore";
        if (a.Pen != b.Pen) return a.Pen < b.Pen ? "Выше по меньшему Error Penalty" : "Ниже из-за большего Error Penalty";
        if (a.Draw != b.Draw) return a.Draw < b.Draw ? "Выше по меньшему Draw History" : "Ниже из-за большего Draw History";
        return string.Empty;
    }

    private static string QualReasonPlayers(PlayerInstance me, List<PlayerInstance> ranked, bool onlyPlayed = true)
    {
        if (me is null || ranked is null || ranked.Count == 0) return string.Empty;

        var pool = onlyPlayed ? ranked.Where(IsPlayed).ToList() : ranked.ToList();
        if (pool.Count == 0) return string.Empty;

        int i = pool.FindIndex(p => ReferenceEquals(p, me) || p.PlayerUserId == me.PlayerUserId);
        if (i < 0)
            i = pool.FindIndex(p => string.Equals(p.PlayerName, me.PlayerName, StringComparison.Ordinal));
        if (i < 0) return string.Empty;

        var myKey = KeyOf(me);

        int start = i;
        while (start > 0 && CompareKeys(KeyOf(pool[start - 1]), myKey) == 0) start--;

        int end = i;
        while (end + 1 < pool.Count && CompareKeys(KeyOf(pool[end + 1]), myKey) == 0) end++;

        int tieSize = end - start + 1;
        if (tieSize > 1)
        {
            var word = RuPlural(tieSize, "игрок", "игрока", "игроков");
            return $"{tieSize} {word} поделили позицию";
        }

        for (int j = i - 1; j >= 0; j--)
            if (CompareKeys(KeyOf(pool[j]), myKey) != 0)
                return DiffReason(me, pool[j]);

        for (int j = i + 1; j < pool.Count; j++)
            if (CompareKeys(KeyOf(pool[j]), myKey) != 0)
                return DiffReason(me, pool[j]);

        return string.Empty;
    }

    private static string RuPlural(int n, string one, string few, string many)
    {
        n = Math.Abs(n) % 100;
        int n1 = n % 10;
        if (n > 10 && n < 20) return many;
        if (n1 > 1 && n1 < 5) return few;
        if (n1 == 1) return one;
        return many;
    }
}