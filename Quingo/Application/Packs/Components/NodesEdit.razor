@inject ApplicationDbContext Db
@inject FileStoreService Files
@inject ISnackbar Snackbar
@inject IDialogService DialogService

<MudText Typo="Typo.h4" GutterBottom>
    Pack Items <MudTooltip Text="Add Item"><MudIconButton OnClick="AddNode" Icon="@Icons.Material.Filled.Add"></MudIconButton></MudTooltip>
</MudText>

<MudGrid Class="pb-4">
    <MudItem xs="12" md="6" lg="4">
        <MudStack Row Wrap="Wrap.NoWrap">
            <MudTextField Placeholder="Search..." @bind-Value="_searchText" @bind-Value:after="ResetPage" DebounceInterval="300" Clearable />
            <MudSelect T="int" MultiSelection Placeholder="Tags" @bind-SelectedValues="@_filterTags" @bind-SelectedValues:after="ResetPage" MultiSelectionTextFunc="GetTagsSelectText" Clearable>
                @foreach (var tag in Pack.Tags)
                {
                    <MudSelectItem T="int" Value="@tag.Id">@tag.Name</MudSelectItem>
                }
            </MudSelect>
        </MudStack>
    </MudItem>
</MudGrid>

<MudGrid>
    @if (NodesFiltered.Count > 0)
    {
        <MudItem xs="12" md="6" lg="4">
            <MudPagination Color="Color.Primary" Count="NumberOfPages" @bind-Selected="_selectedPage" />
        </MudItem>
        <MudFlexBreak />
        @foreach (var node in PageNodes)
        {
            <MudItem xs="12" md="6" lg="4">
                <NodeEdit Node="node" OnSave="SaveNode" OnDelete="ConfirmDeleteNode" />
            </MudItem>
            <MudFlexBreak />
        }
        <MudItem xs="12" md="6" lg="4">
            <MudPagination Color="Color.Primary" Count="NumberOfPages" @bind-Selected="_selectedPage" />
        </MudItem>
    }
    else
    {
        <MudItem xs="12" md="6" lg="4" Style="height: 600px"><i>No Items</i></MudItem>
    }
</MudGrid>

<MudScrollToTop>
    <MudFab Color="Color.Primary" StartIcon="@Icons.Material.Filled.KeyboardArrowUp" />
</MudScrollToTop>

@code {
    [CascadingParameter]
    public Pack Pack { get; set; } = default!;

    private string _searchText = "";

    private IEnumerable<int> _filterTags = [];

    private List<Node> NodesFiltered => Pack?.Nodes?
        .Where(x => (x.Name?.Contains(_searchText, StringComparison.InvariantCultureIgnoreCase) ?? true) && x.DeletedAt == null)
        .Where(x => !_filterTags.Any() || x.NodeTags.FirstOrDefault(t => _filterTags.Contains(t.TagId)) != null)
        .Reverse().ToList() ?? [];

    private const int NodesPerPage = 10;

    private int NumberOfPages => (int)Math.Ceiling((decimal)NodesFiltered.Count / NodesPerPage);

    private int _selectedPage = 1;

    private List<Node> PageNodes => NodesFiltered.Skip((_selectedPage - 1) * NodesPerPage).Take(NodesPerPage).ToList();

    private void ResetPage()
    {
        _selectedPage = 1;
        StateHasChanged();
    }

    private string GetTagsSelectText(List<string> selected)
    {
        var selectedInts = selected.Select(int.Parse).ToList();
        var tags = Pack.Tags.Where(x => selectedInts.Contains(x.Id)).Select(x => x.Name);
        return string.Join(", ", tags);
    }

    private async Task AddNode()
    {
        await SaveNode(0, new NodeModel());
    }

    private async Task SaveNode(int id, NodeModel model)
    {
        if (id == 0)
        {
            var node = new Node
                {
                    Name = model.Name ?? "New Item",
                    Pack = Pack
                };
            Db.Update(node);
        }
        else
        {
            var node = Pack.Nodes.FirstOrDefault(x => x.Id == id);
            if (node == null)
            {
                Snackbar.Add("Item not found", Severity.Error);
                return;
            }

            node.Name = model.Name;

            foreach (var tagId in model.TagIds)
            {
                var nodeTag = node.NodeTags.FirstOrDefault(x => x.TagId == tagId);
                if (nodeTag == null)
                {
                    var tag = Pack.Tags.FirstOrDefault(x => x.Id == tagId);
                    if (tag == null)
                    {
                        Snackbar.Add("Tag not found", Severity.Error);
                        return;
                    }

                    nodeTag = new NodeTag
                        {
                            Node = node,
                            Tag = tag
                        };
                    node.NodeTags.Add(nodeTag);
                }
                else if (nodeTag.DeletedAt != null)
                {
                    nodeTag.DeletedAt = null;
                    nodeTag.DeletedByUserId = null;
                }
            }

            foreach (var nodeTag in node.NodeTags.Where(x => !model.TagIds.Contains(x.Tag.Id)))
            {
                Db.Remove(nodeTag);
            }

            foreach (var linkModel in model.NodeLinks)
            {
                if (linkModel.LinkDirection is NodeLinkDirection.To or NodeLinkDirection.Both)
                {
                    var link = node.NodeLinksFrom.FirstOrDefault(x => x.NodeToId == linkModel.LinkedNodeId);
                    var linkType = Pack.NodeLinkTypes.FirstOrDefault(x => x.Id == linkModel.LinkTypeId);
                    if (linkType == null)
                    {
                        Snackbar.Add("Link Type not found", Severity.Error);
                        return;
                    }

                    var linkedNode = Pack.Nodes.FirstOrDefault(x => x.Id == linkModel.LinkedNodeId);
                    if (linkedNode == null)
                    {
                        Snackbar.Add("Linked Item not found", Severity.Error);
                        return;
                    }

                    if (link == null)
                    {
                        link = new NodeLink
                            {
                                NodeFrom = node,
                                NodeTo = linkedNode,
                                NodeLinkType = linkType
                            };
                        node.NodeLinksFrom.Add(link);
                    }
                    else
                    {
                        if (link.NodeLinkTypeId != linkModel.LinkTypeId)
                        {
                            link.NodeLinkType = linkType;
                        }
                        if (link.DeletedAt != null)
                        {
                            link.DeletedAt = null;
                            link.DeletedByUserId = null;
                        }
                    }
                }

                if (linkModel.LinkDirection is NodeLinkDirection.From or NodeLinkDirection.Both)
                {
                    var link = node.NodeLinksTo.FirstOrDefault(x => x.NodeFromId == linkModel.LinkedNodeId);
                    var linkType = Pack.NodeLinkTypes.FirstOrDefault(x => x.Id == linkModel.LinkTypeId);
                    if (linkType == null)
                    {
                        Snackbar.Add("Link Type not found", Severity.Error);
                        return;
                    }

                    var linkedNode = Pack.Nodes.FirstOrDefault(x => x.Id == linkModel.LinkedNodeId);
                    if (linkedNode == null)
                    {
                        Snackbar.Add("Linked Item not found", Severity.Error);
                        return;
                    }

                    if (link == null)
                    {
                        link = new NodeLink
                            {
                                NodeFrom = linkedNode,
                                NodeTo = node,
                                NodeLinkType = linkType
                            };
                        node.NodeLinksTo.Add(link);
                    }
                    else
                    {
                        if (link.NodeLinkTypeId != linkModel.LinkTypeId)
                        {
                            link.NodeLinkType = linkType;
                        }
                        if (link.DeletedAt != null)
                        {
                            link.DeletedAt = null;
                            link.DeletedByUserId = null;
                        }
                    }
                }
            }

            foreach (var nodeLink in node.NodeLinksFrom)
            {
                var linkModel = model.NodeLinks
                    .FirstOrDefault(x => x.LinkedNodeId == nodeLink.NodeTo.Id && (x.LinkDirection is NodeLinkDirection.Both or NodeLinkDirection.To));
                if (linkModel == null)
                {
                    Db.Remove(nodeLink);
                }
            }

            foreach (var nodeLink in node.NodeLinksTo)
            {
                var linkModel = model.NodeLinks
                    .FirstOrDefault(x => x.LinkedNodeId == nodeLink.NodeFrom.Id && (x.LinkDirection is NodeLinkDirection.Both or NodeLinkDirection.From));
                if (linkModel == null)
                {
                    Db.Remove(nodeLink);
                }
            }

            if (model.ImageFile != null)
            {
                var filename = await Files.UploadBrowserFile(model.ImageFile);
                node.ImageUrl = filename;
            }
        }

        await Db.SaveChangesAsync();
        StateHasChanged();
    }

    private async Task ConfirmDeleteNode(int id)
    {
        var node = Pack.Nodes.FirstOrDefault(x => x.Id == id);
        if (node == null)
        {
            Snackbar.Add("Item not found", Severity.Error);
            return;
        }

        var parameters = new ConfirmDialog.ConfirmDialogParams
            {
                Prompt = $"Delete item {node.Name}?",
                ButtonText = "Delete",
                ButtonColor = Color.Error
            };
        var confirmed = await ConfirmDialog.CallDialog(DialogService, parameters);

        if (confirmed)
        {
            await DeleteNode(node);
        }
    }

    private async Task DeleteNode(Node node)
    {
        Db.Remove(node);
        await Db.SaveChangesAsync();
        StateHasChanged();
    }
}
