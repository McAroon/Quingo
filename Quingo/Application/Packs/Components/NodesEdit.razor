@inject PackRepo Repo
@inject FileStoreService Files
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject NavigationManager Navigation
@inject IJSRuntime Js

<div id="nodes-edit"></div>
<MudText Typo="Typo.h4" GutterBottom>
    Pack Items <MudTooltip Text="Add Item"><MudIconButton OnClick="AddNode" Icon="@Icons.Material.Filled.Add"></MudIconButton></MudTooltip>
</MudText>

<MudGrid Class="pb-4">
    <MudItem xs="12">
        <MudStack Row Wrap="Wrap.NoWrap">
            <MudTextField Placeholder="Search..." @bind-Value="Search" @bind-Value:after="() => OnQueryChange(true)" DebounceInterval="500" Clearable />
            <MudSelect T="int" MultiSelection Placeholder="Tags" @bind-SelectedValues="@TagIdsEnumerable" @bind-SelectedValues:after="() => OnQueryChange(true)" MultiSelectionTextFunc="GetTagsSelectText" Clearable>
                @foreach (var tag in Pack.Tags)
                {
                    <MudSelectItem T="int" Value="@tag.Id">@tag.Name</MudSelectItem>
                }
            </MudSelect>
        </MudStack>
    </MudItem>
</MudGrid>

<MudGrid>
    @if (_nodes is { Count: > 0 })
    {
        <MudItem xs="12">
            <MudPagination Color="Color.Primary" Count="NumberOfPages" @bind-Selected="Page" @bind-Selected:after="() => OnQueryChange()" />
        </MudItem>
        <MudFlexBreak />
        @foreach (var node in _nodes.Data)
        {
            <MudItem xs="12">
                <NodeEdit Node="node" OnSave="SaveNode" OnDelete="ConfirmDeleteNode" NodeInfos="_nodeInfos" />
            </MudItem>
            <MudFlexBreak />
        }
        <MudItem xs="12">
            <MudPagination Color="Color.Primary" Count="NumberOfPages" @bind-Selected="Page" @bind-Selected:after="() => OnQueryChange()" />
        </MudItem>
    }
    else
    {
        <MudItem xs="12" Style="height: 600px"><i>No Items</i></MudItem>
    }
</MudGrid>

<MudScrollToTop>
    <MudFab Color="Color.Primary" StartIcon="@Icons.Material.Filled.KeyboardArrowUp" />
</MudScrollToTop>

@code {
    [CascadingParameter] public Pack Pack { get; set; } = default!;

    [SupplyParameterFromQuery(Name = "page")] private int Page { get; set; } = 1;

    [SupplyParameterFromQuery(Name = "search")] private string Search { get; set; } = "";

    [SupplyParameterFromQuery(Name = "tag_id")] private int[] TagIds { get; set; } = [];

    [SupplyParameterFromQuery(Name = "order_by")] private int? OrderBy { get; set; } = (int)PackNodesOrderBy.CreatedAt;

    [SupplyParameterFromQuery(Name = "direction")] private int? Direction { get; set; } = (int)OrderDirection.Descending;

    private Dictionary<string, object?> QueryParameters => new()
    {
        ["page"] = Page,
        ["search"] = Search,
        ["tag_id"] = TagIds,
        ["order_by"] = OrderBy,
        ["direction"] = Direction,
    };
    
    private PagedResult<Node> _nodes = default!;
    
    private IEnumerable<int> TagIdsEnumerable
    {
        get => TagIds;
        set => TagIds = value.ToArray();
    }

    private const int NodesPerPage = 10;

    private int NumberOfPages => (int)Math.Ceiling((decimal)_nodes.Count / NodesPerPage);

    private List<LinkedNodeInfoModel> _nodeInfos = [];

    private async Task LoadPackNodes()
    {
        if (Page < 1)
        {
            Page = 1;
        }
        var orderBy = OrderBy.HasValue && Enum.IsDefined(typeof(PackNodesOrderBy), OrderBy) ? (PackNodesOrderBy)OrderBy : PackNodesOrderBy.CreatedAt;
        var direction = Direction.HasValue && Enum.IsDefined(typeof(OrderDirection), Direction) ? (OrderDirection)Direction : OrderDirection.Descending;
        _nodes = await Repo.GetPackNodes(Pack, Page, NodesPerPage, Search, TagIds.ToList(), orderBy, direction);
        StateHasChanged();
    }

    protected override async Task OnInitializedAsync()
    {
        var nodeNames = await Repo.GetPackNodeNames(Pack.Id);
        _nodeInfos = nodeNames.Select(x => new LinkedNodeInfoModel(x.id, x.name)).ToList();
    }

    protected override async Task OnParametersSetAsync()
    {
        await LoadPackNodes();
    }

    private async Task OnQueryChange(bool resetPage = false)
    {
        if (resetPage)
            Page = 1;

        var uri = Navigation.GetUriWithQueryParameters(QueryParameters);
        if (!uri.Contains("#nodes-edit"))
            uri += "#nodes-edit";
        
        await LoadPackNodes();
        await Js.InvokeAsync<string>("window.history.pushState", null, "", uri);
        await Js.InvokeAsync<bool>("window.scrollToElementId", "nodes-edit");
    }

    private string GetTagsSelectText(List<string> selected)
    {
        var selectedInts = selected.Select(int.Parse).ToList();
        var tags = Pack.Tags.Where(x => selectedInts.Contains(x.Id)).Select(x => x.Name);
        return string.Join(", ", tags);
    }

    private async Task AddNode()
    {
        await SaveNode(0, new NodeModel());
    }

    private async Task SaveNode(int id, NodeModel model)
    {
        await using var context = await Repo.CreateDbContext();
        
        if (id == 0)
        {
            var node = new Node
                {
                    Name = model.Name ?? "New Item",
                    Pack = Pack
                };
            context.Update(node);
        }
        else
        {
            var node = _nodes.Data.FirstOrDefault(x => x.Id == id);
            if (node == null)
            {
                Snackbar.Add("Item not found", Severity.Error);
                return;
            }

            node.Name = model.Name;

            foreach (var tagId in model.TagIds)
            {
                var nodeTag = node.NodeTags.FirstOrDefault(x => x.TagId == tagId);
                if (nodeTag == null)
                {
                    var tag = Pack.Tags.FirstOrDefault(x => x.Id == tagId);
                    if (tag == null)
                    {
                        Snackbar.Add("Tag not found", Severity.Error);
                        return;
                    }

                    nodeTag = new NodeTag
                        {
                            Node = node,
                            Tag = tag
                        };
                    node.NodeTags.Add(nodeTag);
                }
                else if (nodeTag.DeletedAt != null)
                {
                    nodeTag.DeletedAt = null;
                    nodeTag.DeletedByUserId = null;
                }
            }

            foreach (var nodeTag in node.NodeTags.Where(x => !model.TagIds.Contains(x.Tag.Id)))
            {
                context.Remove(nodeTag);
            }

            foreach (var linkModel in model.NodeLinks)
            {
                if (linkModel.LinkDirection is NodeLinkDirection.To or NodeLinkDirection.Both)
                {
                    var link = node.NodeLinksFrom.FirstOrDefault(x => x.NodeToId == linkModel.LinkedNodeId);
                    var linkType = Pack.NodeLinkTypes.FirstOrDefault(x => x.Id == linkModel.LinkTypeId);
                    if (linkType == null)
                    {
                        Snackbar.Add("Link Type not found", Severity.Error);
                        return;
                    }

                    var linkedNode = _nodeInfos.FirstOrDefault(x => x.Id == linkModel.LinkedNodeId);
                    if (linkedNode == null)
                    {
                        Snackbar.Add("Linked Item not found", Severity.Error);
                        return;
                    }

                    if (link == null)
                    {
                        link = new NodeLink
                            {
                                NodeFrom = node,
                                NodeToId = linkedNode.Id,
                                NodeLinkType = linkType
                            };
                        node.NodeLinksFrom.Add(link);
                    }
                    else
                    {
                        if (link.NodeLinkTypeId != linkModel.LinkTypeId)
                        {
                            link.NodeLinkType = linkType;
                        }
                        if (link.DeletedAt != null)
                        {
                            link.DeletedAt = null;
                            link.DeletedByUserId = null;
                        }
                    }
                }

                if (linkModel.LinkDirection is NodeLinkDirection.From or NodeLinkDirection.Both)
                {
                    var link = node.NodeLinksTo.FirstOrDefault(x => x.NodeFromId == linkModel.LinkedNodeId);
                    var linkType = Pack.NodeLinkTypes.FirstOrDefault(x => x.Id == linkModel.LinkTypeId);
                    if (linkType == null)
                    {
                        Snackbar.Add("Link Type not found", Severity.Error);
                        return;
                    }

                    var linkedNode = _nodeInfos.FirstOrDefault(x => x.Id == linkModel.LinkedNodeId);
                    if (linkedNode == null)
                    {
                        Snackbar.Add("Linked Item not found", Severity.Error);
                        return;
                    }

                    if (link == null)
                    {
                        link = new NodeLink
                            {
                                NodeFromId = linkedNode.Id,
                                NodeTo = node,
                                NodeLinkType = linkType
                            };
                        node.NodeLinksTo.Add(link);
                    }
                    else
                    {
                        if (link.NodeLinkTypeId != linkModel.LinkTypeId)
                        {
                            link.NodeLinkType = linkType;
                        }
                        if (link.DeletedAt != null)
                        {
                            link.DeletedAt = null;
                            link.DeletedByUserId = null;
                        }
                    }
                }
            }

            foreach (var nodeLink in node.NodeLinksFrom)
            {
                var linkModel = model.NodeLinks
                    .FirstOrDefault(x => x.LinkedNodeId == nodeLink.NodeToId && (x.LinkDirection is NodeLinkDirection.Both or NodeLinkDirection.To));
                if (linkModel == null)
                {
                    context.Remove(nodeLink);
                }
            }

            foreach (var nodeLink in node.NodeLinksTo)
            {
                var linkModel = model.NodeLinks
                    .FirstOrDefault(x => x.LinkedNodeId == nodeLink.NodeFromId && (x.LinkDirection is NodeLinkDirection.Both or NodeLinkDirection.From));
                if (linkModel == null)
                {
                    context.Remove(nodeLink);
                }
            }

            if (model.ImageFile != null)
            {
                var filename = await Files.UploadBrowserFile(model.ImageFile);
                node.ImageUrl = filename;
            }
        }

        await context.SaveChangesAsync();
        await LoadPackNodes();
    }

    private async Task ConfirmDeleteNode(int id)
    {
        var node = _nodes.Data.FirstOrDefault(x => x.Id == id);
        if (node == null)
        {
            Snackbar.Add("Item not found", Severity.Error);
            return;
        }

        var parameters = new ConfirmDialog.ConfirmDialogParams
            {
                Prompt = $"Delete item {node.Name}?",
                ButtonText = "Delete",
                ButtonColor = Color.Error
            };
        var confirmed = await ConfirmDialog.CallDialog(DialogService, parameters);

        if (confirmed)
        {
            await DeleteNode(node);
        }
    }

    private async Task DeleteNode(Node node)
    {
        await using var context = await Repo.CreateDbContext();
        context.Remove(node);
        await context.SaveChangesAsync();
        StateHasChanged();
    }
}
